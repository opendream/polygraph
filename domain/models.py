from datetime import datetimefrom django.contrib.auth import get_user_modelfrom django.core import validatorsfrom django.db import modelsfrom django.utils import timezonefrom django.utils.translation import ugettext_lazy as _from ckeditor.fields import RichTextFieldfrom common.models import CommonTrashModelfrom collections import namedtupleimport reclass AbstractPeopleField(models.Model):    first_name = models.CharField(max_length=30, null=True, blank=True)    last_name = models.CharField(max_length=30, null=True, blank=True)    occupation = models.CharField(max_length=255, null=True, blank=True)    description = RichTextField(null=True, blank=True)    homepage_url = models.CharField(max_length=255, null=True, blank=True)    class Meta:        abstract = True    def get_full_name(self):        """        Returns the first_name plus the last_name, with a space in between.        """        full_name = '%s %s' % (self.first_name, self.last_name)        return full_name.strip()    def get_short_name(self):        "Returns the short name for the user."        if self.first_name.strip() and self.last_name.strip():            return '%s.%s' % (self.first_name.strip(), self.last_name.strip()[0])        elif self.first_name.strip():            return self.first_name.strip()        elif self.last_name.strip():            return self.last_name.strip()        return ''class AbstractPermalink(models.Model):    class Meta:        abstract = True    permalink = models.CharField(max_length=30, unique=True,        help_text=_('Required unique 30 characters or fewer. Letters, numbers and '                    './+/-/_ characters'),        validators=[            validators.RegexValidator(re.compile('^[\w.+-]+$'), _('Enter a valid permalink.'), 'invalid')        ])    def __unicode__(self):        return self.permalink    @property    def inst_name(self):        return _(self.__class__.__name__)class People(CommonTrashModel, AbstractPeopleField, AbstractPermalink):    passclass Topic(CommonTrashModel, AbstractPermalink):    def __init__(self, *args, **kwargs):        super(Topic, self).__init__(*args, **kwargs)        topic_revision_list = self.topicrevision_set.order_by('created')        # Prepare field        self.revision_fields = {}        self.revision_fields['created_by'] = kwargs.get('created_by')        self.revision_fields['title'] = kwargs.get('title')        self.revision_fields['description'] = kwargs.get('description')        self.revision_fields['created'] = kwargs.get('created')        self.revision_fields['changed'] = kwargs.get('changed')        RevisionStruct = namedtuple('RevisionStruct', ' '.join(self.revision_fields.keys()))        revision_struct_fields = RevisionStruct(**self.revision_fields)        self.latest_revision = revision_struct_fields        self.oldest_revision = revision_struct_fields        try:            self.latest_revision = topic_revision_list[topic_revision_list.count()-1]            self.oldest_revision = topic_revision_list[0]        except AssertionError:            pass        # Store attributes        self._created_by = self.latest_revision.created_by        self._title = self.latest_revision.title        self._description = self.latest_revision.description        self._created = self.oldest_revision.created        self._changed = self.latest_revision.created        for field, value in kwargs.items():            setattr(self, '_%s' % field, value)    @property    def created_by(self):        return self._created_by    @property    def title(self):        return self._title    @property    def description(self):        return self._description    @property    def created(self):        return self._created    @property    def changed(self):        return self.l_changed    @created_by.setter    def created_by(self, value):        self._created_by = value    @title.setter    def title(self, value):        self._title = value    @description.setter    def description(self, value):        self._description = value    @created.setter    def created(self, value):        self._created = value    @changed.setter    def changed(self, value):        self._changed = value    def save(self, without_revision=False, *args, **kwargs):        if not without_revision:            if not self._created:                self._created = timezone.now()            topic_revision = TopicRevision.objects.create(                created_by = self._created_by,                title = self._title,                description = self._description,                created = self._created            )            if self._changed and self._changed != self.latest_revision.created:                self.latest_revision.created = self._changed                self.latest_revision.save()            super(Topic, self).save(*args, **kwargs)            topic_revision.origin = self            topic_revision.save()        else:            super(Topic, self).save(*args, **kwargs)class TopicRevision(models.Model):    origin = models.ForeignKey(Topic, null=True)    created_by = models.ForeignKey(get_user_model())    title = models.CharField(max_length=255, null=True, blank=True)    description = RichTextField(null=True, blank=True)    created = models.DateTimeField()